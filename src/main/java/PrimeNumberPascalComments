// В этом файле находится код программы для вычисления n-ого простого числа на языке Pascal с комментариями.
// Мне не хочется добавлять комментарии в грамматику языка, поэтому для выполнения компиляции будет использован файл
// PrimeNumberPascal. В нем находится текст этой же программы, но без комментариев, бех пустых строи и отступов.
// Так же все ключевые слова языка пишутся большими буквами, а имена переменных - маленькими.
// Плюс к этому, в данной программе есть измерение времени ее выполнения. В компилируемой версии - нет.

// Блок констант. Фактически, тут задается номер искомого простого числа
const
n = 10000;

// Блок переменных.
var
count: integer;      // В этой переменной хранится количество уже найденных простых чисел
k: integer;          // В этой переменной хранится число, проверяемое на простоту в данный момент
divisors: integer;   // В этой переменной хранится число простых делителей числа k
lst: array [0..n] of integer;   // В этом массиве хранятся уже найенные простые числа
t1: integer;
t2: integer;
t: double;

// Начало программы
begin
  t1 := Milliseconds;
  count := 1;        // Будем считать, что простое число 2 уже найдено
  k := 3;            // Начнем проверку на простоту с числа 3
  divisors := 0;     // На данном этапе у проверяемого числа 0 простых делителей
  lst[0] := 2;       // В массив простых чисел добавляем простое число 2
  // Если нужно найти первое простое число, то ничего вычислять не надо. Возвращаем число 2
  if (n = 1) then
  begin
    writeln('2');
  end
  // В противном случае приступаем к вычислениям
  else
  begin
    // Вычисления будет происходить пока количество найденных простых чисел не совпадет с заданной константой
    while (count <> n) do
    begin
      // Проверим, являются ли найденные простые числа делителями проверяемого числа
      // Проверяем только простые числа, так как если они не делят проверяемое число, то составные тоже не делят
      for var i := 0 to count - 1 do
      begin
        // Если является, то увеличиваем число делителей на 1
        if (k mod lst[i] = 0) then
        begin
          divisors := divisors + 1;
        end;
      end;
      // Теперь проверим сколько простых делителей было найдено для простого числа
      // Если ни одного, то проверяемое число добавляем к простым, а их количество увеличиваем на 1
      if (divisors = 0) then
      begin
        lst[count] := k;
        count := count + 1;
      end
      // Если деители были найдены, то число нам не подходит. Просто обнуляем счетчик
      else
      begin
        divisors := 0;
      end;
      // Переходим к следующему проверяемому на простоту числу. Четные числа на проверяются
      k := k + 2;
    end;
    // После того, как количество найденных простых чисел совпало с константой, возвращаем последнее найденное число
    writeln(k - 2);
  end;
  t2 := Milliseconds;
  t := (t2 - t1) / 1000;
  writeln(t);
// Конец программы
end.